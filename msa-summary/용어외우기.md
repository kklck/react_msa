# IT 용어

### MSA

![img](https://media.vlpt.us/post-images/tedigom/575c07d0-f980-11e9-ac2c-696993348d8a/pic1.png)

> **MicroService Architecture** <=> Monolithic 
>
> - SOA(서비스 지향 아키텍쳐)로서 소프트웨어 개발 기법.
> - 큰 어플리케이션을 작은 어플리케이션으로 쪼갬
> - 모놀리틱의 한계 극복
>   - 부분 장애가 전체서비스로 확대 가능성
>   - 실제 사용되지 않는 서비스도 모두 동작하기에 Scale-Out 분산 처리 어려움
>   - 여러 컴포넌트가 하나의 서비스로 결합 -> 서비스 변경, 수정 시 영향 정도 파악 힘듬
>   - 미세한 변경에도 많은 테스트 비용 발생
>   - 많은 개발자가 하나의 시스템 배포 -> CI/CD 어려움 -> 배포시간 증가
>   - 하나의 언어나 프레임워크에 종속적
>
> **특징**
>
> - 섬세하고 가벼운 프로토콜을 가진 작은 서비스
> - API 형태로만 상호작용 가능
> - 하나의 비즈니스를 위해 자신이 개발하는 서비스만 책임
> - 여러 애플리케이션에서 재사용 가능
>
> **기존 SOA와 다른점**
>
> - 집중화된 관리체계 X
> - EBS(Enterprise Service Bus) 같은 무거운 제품 의존 X
> - Rest, Kafka 등 가볍고 심플한 제품 사용
>
> --------
>
> **장점**
>
> - 모듈화된 서비스끼리 RPC/message-driven API 통신 => 각각의 서비스 개발 속도 증가, 유지보수 쉬움
>   - **RPC**(Remote Procedure Call) : 원격 프로시저 호출
>     - 외부 프로세스와 상호작용 기능
>     -   TCP/IP 혹은 IPC 상위서 작동 => 내부 프로시저 호출하는 것처럼 보이도록 추상화 계층 제공
>     - 플랫폼, 언어 달라도 RPC 인터페이스 구현하여 호출 가능
>     - ex) CORBA, SOAP, RMI 등
> - 팀 단위로 다양한 기술 스택(Spring-Node.js)
>   - **Polyglot** : 여러 언어로 개발하는 방식
> - 서비스 별 독립적 배포 가능 => 가벼운 CD
> - 각각의 부하에 개별 Scale-Out 가능
>
> **단점**
>
> - 복합한 서비스 구조, 내부 통신과 부하 발생 시 트랜잭션 관리 어려움
> - API 호출로 통신 비용이나 동기적 지연 발생
> - 통합 테스트 어려움 => 실제 운영환경 배포 힘듬, 연동 확인 필수
> - 소규모에 부적합

### SOA

> **Service Oriented Architecture**
>
> - 대규모 시스템 구축에 쓰이는 개념
> - 소프트웨어 서비스를 네트워크와 연동해 시스템 구축하는 방법론
> - 업무 처리 변화를 시스템에 빠르게 반영하고자 등장
>
> **특징**
>
> - 플랫폼에 비 종속적, 느슨결합, 상호조합 가능
> - 각각의 서비스가 데이터 계층/비즈니스 로직/뷰 모듈 가지고 서로 의존성 최소화
> - 서비스 중복을 경계해야 함

### EDA(EDM)

> **Event-Driven Architecture**(MicroService)
>
> - 이벤트 기반의 아키텍쳐
>
> - MSA도입 시 발생되는 새로운 요구사항(허들) 달성하는 개념
>   - DB per Service
>     - 자산 관련 데이터 관리
>     - 데이터 기반 인사이트 확보에 약점 => 의사결정 어려움
>     - 관계형 DB로 효율적 데이터 관리 불가
>     - 비즈니스 설계 시 스키마/테이블 설계 줄어듬
>     - DB 분리 시, 발생 비용
>   - Rest(동기) 통신
>     - 서비스 추가/반정규화 데이터 변경 시, 해당 데이터 사용하는 서비스 수정 가능성
>     - 단일 기능 서비스는 자동화 서비스가 될 가능성
>     - 복원 값 찾기 어려움
>     - API Gateway 요청 시, 응답 할때까지 연관 서비스 홀딩
>   - 서비스 간 트랜잭션 처리/반정규화 데이터 동기 처리 문제 등
>
> **정의**
>
> - 컴퓨터 회로를 구동시키는 동작(I/O 장치 동작)
> - 어떤 일의 결과나 반응으로 동작하는 디자인 패턴
> - 센서로부터 유입되는 데이터 스트리밍 기반 동작
> - 시스템 내외부에서 발생한 **주목할 만한**(Creadte,Update, Delete) 상태 변화 주는 동작
>
> **특징**
>
> - MSA가 적용된 시스템에서 이벤트 발생 시 => 로그 보관/반응 동작/비동기 통신으로 시스템 내 통합
>
>   - 이벤트 로그
>
>     - 현재 상태 구성하는 근간, 장애 발생 시 복원 수행
>
>     - 이벤트 스토어에 로그 저장
>
>   - 비동기 통신
>
>     - 메시징 프로토콜 통한 메시지 큐 방식 자주 사용
>     - 반응 동작으로 메시지 형태의 이벤트 발행(Pub) => 구독(Sub) 수행
>
>   - 시스템 내 통합(비동기 메시지 큐)
>
>     - 서비스 간 결합도 낮아짐
>     - 서비스 흐름 단순
>     - 발행 서비스는 구독 고려 할 필요 없이 CUD 발생 시 동작
>     - 구독 서비스는 메시지 큐 라우팅 룰 따라 비즈니스 로직 수행
>     - 실시간 처리 기능 우선 - 후속 동작은 메시지 큐로 적용 => 응답 지연시간 낮아짐
>
>     - MSA는 의존의 최소화를 표방하지만, 현실적으로 내부 통신이 없을 수 없다.
>
> **의의**
>
> - MSA의 데이터 무결성을 보장할 수 없지만, 데이터의 일관성은 유지할 수 있다.
>   - **all commit or rollback** → **eventually consistency**
>
> **MSA 말고 왜 써야 하나?**
>
> - DB Per Service 보완
>
>   - 어플리케이션 레벨에서 트랜잭션 처리하여 서비스 최적화 DB 선택할 수 있다.
>
> - 비즈니스 흐름 따른 로직 수행
>
>   - 상태 변경 => 이벤트 발생 => 해당 이벤트 구독한 서비스가 기능 수행 => 반복
>   - 무한루프 방지 체크 필요
>
> - 분산 트랜잭션 처리
>
>   - 서비스 연동 시 오류 => MSA는 롤백 불가 => EDM은 로그 기반 롤백 가능, 메시지 큐 사용해 Retry 수행
>
> - 서비스 간 반정규화 데이터 동기 처리
>
>   ![img](https://miro.medium.com/max/314/0*t4H3XkhJkEjsKrpb.png)
>
>   - REST 데이터 커짐 => 반정규화 발생 => 서비스 간 데이터 동기 처리
>   - 자기 서비스에 영향 줄 이벤트를 구독해 변경사항 반영
>
> - 시스템 내 통합
>
>   - 비동기 메시지 큐를 통해 동작
>   - 메시지 전달 신뢰성 문제 유의
>   - RabbitMQ, Kafka 등 Backing Service 사용해 큐 메시지 정렬
>     - 멱등성, 이벤트 적재하여 복원 등
>
> - 일관성 유지
>
>   - all commit or rollback → eventually consistency
>
> **유의**
>
> - 비동기로 세부 단계 수행 시, 사용자와 인터랙션을 통해 상태 변경하는 방식은 적합 X => 가장 앞단에서 데이터 세팅을 마치고 백엔드로 전달하는 재설계 필요
> - 특정 방식에 따른 개발 보다는 조직/개인 역량에 맞는 방법 선택하는 것 중요

https://medium.com/dtevangelist/event-driven-microservice-%EB%9E%80-54b4eaf7cc4a

### ACID

> **DB 트랜잭션 보장 성질**
>
> - 원자성(Atomicity) : 부분적으로 동작중인 작업은 절대 중단되지 않는다
>   - 이체할 때, 중단되면 안됌
> - 일관성(Consistency) : 트랜잭션 성공적으로 완료 시, 일관성 있는 DB 유지
>   - 일관성 위반하는 트랜잭션은 중단
> - 독립성(Isolation) : 다른 트랜잭션의 연산이 끼어들지 못하도록 한다
>   - 연산의 중간 과정 데이터를 볼 수 없게 하기 위해
> - 지속성(Durability) : 성공적인 트랜잭션은 영원하라~

### Message Queue

> **MSA의 데이터 송수신하는 미들웨어**
>
> - 기존 Server-Client : 결합도 높음 => 동기식 => 의존성 높힘, 유연성 낮음
> - MSA의 메시지 큐 : 비동기식 => 결합도 낮음
>
> **특징**
>
> - 비동기/약결합
> - 서비스 실패해도 재처리 가능
> - 전체 영향 적고, 회복 탄력성 높음
> - 메시지 큐에 들어가면 수행 보장
> - 메시지 큐의 수를 늘려 많은 요청에 유연한 확장

### Backing Service

> **애플리케이션 실행 중에 네트워크 통해 사용할 수 있는 모든 서비스**
>
> - DB(my_sql, NoSql, SMTP)

#### Apache Kafka

> **Pub/Sub 구조에 특화된 메시지 큐, 분산 설계**
>
> - 대용량 및 실시간 처리 특화
> - 단순한 TCP 사용 => 오버헤드 감소
> - 파일 시스템에 메시지 저장
> - OS에서 처리하는 페이지 캐시 사용하여 빠른 속도
> - 이용자가 pull로 메시지 받으며, batch 가능

### CQRS

> **Command and Query Responsibility Sergregation**
>
> - 명령과 조회 책임 분리
>   - 상태 변경과 상태 반환 작업의 **책임**을 분리하자

### Hexsagonal Architecture

> **비즈니스 로직(내부), 인터페이스 처리(외부)로 나뉜 아키텍쳐**
>
> **등장**
>
> - 레이어 아키텍쳐에 DIP(의존성 역전 원칙) 적용에 한계 + 인프라에 의존하는 도메인 => 도메인과 기술적 관심이 섞임
> - MSA에서 다양한 인터페이스 필요로 하지만, 시스템 관점에서 호출 시스템과 인프라 간 차이는 미세
>
> **구조**
>
> ![](https://blog.kakaocdn.net/dn/YOBXU/btq1e8bAsWC/yKrQl5ra7HmWMHA6soCmLk/img.png)
>
> - 내부
>   - 비즈니스 로직 표현
>   - 외부와 연계되는 Port 존재
> - 외부
>   - 인바운드 어댑터 : 밖으로부터 받은 요청 처리
>   - 아웃바운드 어댑터 : 비즈니스 로직 으로부터 호출되어 밖과 연계

### DDD

> **Domain Driven Design**
>
> - 비즈니스 도메인 별로 나누어 설계하는 방법
>   - 도메인 이해 부족 상태에서 개발하는 것을 반성
>   - IT 업무의 쌍방향 커뮤니케이션 강조
> - 응집도 높히고 결합도 낮춰 의존성 최소화를 목표
>
> **디자인 구성**
>
> - Strategic Design
>
>   - 비즈니스 도메인의 **Context(사용자/상황)**에 맞게 설계하자
>     - ex) 선물은 대상에 알맞게 사야죠
>   - Context를 Event Storming으로 공유 => 비즈니스 목적 별로 서비스 그룹핑
>
>   - Bounded Context
>     - 비즈니스 도메인의 사용자/프로세스/정책/규정 등을 공유한 비즈니스 목적 별로 그룹핑
>   - 도메인 모델
>     - 비즈니스 도메인 서비스 추상화 설계도
>     - 서브 도메인들 + Bounded Context
>   - Context Map
>     - Bounded Context 간 관계 도식화 한 다이어그램
>   - Ubiquitous Language
>     - 개발 참여자들이 동일한 의미로 이해하는 언어
>     - 비즈니스 도메인 따라 정확한 커뮤니케이션 위해 공통언어 정의
>   - 비즈니스 도메인 분할
>     - Core : 비즈니스 목적 달성 위한 핵심 도메인 차별화, 가장 많은 투자
>       - 주문, 주문중계/중개, 음식점 업무, 배달 대행
>     - Supporting : 핵심 도메인 지원하는 도메인
>       - 주문, 음식평가, 주문처리, 음식점관리, 조리, 배달, 배차, 라이더 관리 등
>     - Generic : 공통 기능 서드파티 구매하는 게 효율적
>       - 메일, 통합인증

### 시스템 통합방법

##### Request/Response

> **HTTP 프로토콜을 사용하는 통신 방식**
>
> ![Spring Boot Redis Pub/Sub](https://t1.daumcdn.net/thumb/R720x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/2MrI/image/DMW5elDyxpimw1H7qdG4fLHOY_4.png)
>
> - Statless, 상태를 저장하지 않지만, 클라이언트에 유지중
> - 단순한 구조 => 쉬운 구현
> - Client-Server 의존성 강함 => 서버가 실행 중일 때만 통신 가능
> - 서로의 메시지를 기다리는 동기식 통신

##### 메시징

> **메시징 시스템을 통해 데이터 전송하는 포괄적 용어![img](https://t1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/2MrI/image/qagurggmARSBzy6tMDMBtren32M.png)**
>
> - 발신자(서버)는 수신자(클라이언트)를 특정할 수 없으며, 서로의 채널만 알고있음
> - 느슨결합 비동기 방식 => MSA에 적합
>
> **Publish/Subscribe**
>
> ![img](https://t1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/2MrI/image/Xi6Qz98EG9hfWuFd5a9S02veKJk.png)

### 빌드 관리도구

##### Maven

> **프로젝트의 전체적인 라이프사이클을 관리하는 도구**
>
> - apache Ant 대안, apache 라이센스로 배포되는 오픈소스 소프트웨어
> - 사용할 lib + 해당 lib 작동에 필요한 lib 관리/다운로드
> - 환경 변수만 잡아주면 JDK 자동 설치
> - 플러그인 기반 기능 제공 → 동작의 목적은 플러그인의 목적
> - 각 서비스끼리 특정 설정 상속 받아야 함
>
> **LifeCycle** Phase
>
> - Clean : 이전 빌드에서 생성된 파일들을 삭제하는 단계
> - Validate : 프로젝트가 올바른지 확인학고 필요한 모든 정보를 사용할 수 있는 지 확인하는 단계
> - Compile : 프로젝트의 소스코드를 컴파일하는 단계
> - Test : 유닛(단위) 테스트를 수행하는 단계(테스트 실패시 빌드 실패로 처리, 스킵 가능)
> - Package : 실제 컴파일된 소스 코드와 리소스들을 jar등의 배포를 위한 패키지로 만드는 단계
> - Verify : 통합테스트 결과에 대한 검사를 실행하여 품질 기준을 충족하는지 확인하는 단계
> - Install : 패키지를 로컬 저장소에 설치하는 단계
> - Site : 프로젝트 문서를 생성하는 단계
> - Deploy : 만들어진 Package를 원격 저장소에 release하는 단계
>
> **POM**
>
> - Project Object Model
> - 프로젝트의 정보(프로젝트 이름/개발자 목록/라이센스)
> - 빌드 설정(소스/리소스/사이클 별 플러그인/사용자 환경 별 프로파일)
> - 연관 정보(모듈, 상/하위 프로젝트)
> - .xml

##### Gradle

> - Ant 와 Maven 장점 합침
> - groovy 기반 스크립트 언어 => JVM 위에서 빌드 동작, 컴파일 필요 없음
> - 별도의 로직 구현 가능
> - 설정 주입 방식
>
> **Maven 보다 좋은 점**
>
> - 작성 언어가 받아들이기 쉬움
> - 설정 상속보다 설정  주입이 멀티 프로젝트에서 속도가 빠름

### Cloud Native Application

#### The Twelve-Factor App

> **SaaS?**
>
> - Software as a Service
> - 체계화된 설정 자동화 절차 => 새로 참여한 개발자의 시간과 비용 최소화
> - OS 따라 달라지는 부분 명확히, 환경 사이 이식성 극대화
> - 클라우드 플랫폼에 적합
> - 서버/시스템 관리 불필요
> - 개발-운영 환경 차이 최소화 => 지속적 통합 가능
> - Scale-Up

### Spring Cloud

> **분산 시스템에서 공통적인 패턴을 모아 신속하게 구축할 수 있는 도구를 스프링 라이브러리 형태로 제공**
>
> - 구성관리/서비스검색/지능형라우팅/MS프록시 등 패턴 존재
>
> **제공 기능**
>
> - 분산/버전 설정
>   - 중앙에서 설정 값 관리
>   - 각각 서비스에 문의하여 설정 값 가져올 수 있음
> - 서비스 등록 및 조회
>   - 각각 서비스는 중앙에 **서비스 이름**을 Key로 등록 => Key로 서로 서비스를 호출해  Value(위치) 받음
>   - Eureka, Consul, Zookeeper 연동 지원
> - 라우팅
>   - 특정 네트워크 내부에서 목적지 찾아가는 과정
>   - API Gateway
>     - 서비스 사이 중계 및 변환/추가 모듈
>   - zuul, Spring cloud Gateway 가 제공
> - 서비스 간 호출
>   - 신뢰할 수 있는 내부망에서도 SSL 작업은 불필요 => 부하 발생
>   - 일대일 호출
>     - 직접 서비스 주소 찾아 호출
>     - Ribbon 활용
>       -  Client 사이드 부하 분산 솔루션
>   - 일대다 호출
>     - 분산 메시징 활용
>     - Spring Cloud Netfilx(Ribbon) 지원
> - 부하 분산
>   - 동일한 서비스 처리하는 인스턴스 중 적합한 것 호출하고 부하 분산해야 함
>   - API Gateway, Client 사이드 부하 분산 솔루션 활용
> - 서킷 브레이커
>   - 장애 발생 시, 회피 방법
>   - 장애 발생한 인스턴스로 가는 요청 **중단**
>   - Ribbon, Zuul 활용
> - Global locks, Leadership election and Cluster state
>   - 특정 리소스에 **하나의 모듈만** 접근해야 할 때 => Global Lock
>   - 접근 권한 가지는 리더 선택
>   - Consul, Zookeeper 기능 제공
> - 분산 메시징
>   - 메시지 큐잉 활용
>     - 주문 완료 => 고객과 배달자에게 문자 + 서비스 메인 모듈에 전달
>   - Pub/Sub
>     - Consumer Group 활용해 중복처리 방지
>     - Partitioning 기능
>   - Spring Cloud Stream 지원
>     - RabbitMQ, Kafka, Google PubSub
>
> **활용 컴포넌트**

### Feign Client

> **Web Serivce 클라이언트를 쉽게 작성**
>
> - 넷플릭스 오픈소스
> - Application.java에 @EnableFeignClients
>
> **Client**
>
> - 인터페이스로 작성
> - @FeignClient(name, url)
>
> **Service**

# 보험 용어

### 대면채널

> 보험 회사와 계약 맺은 개인 보험 설계사를 통한 보험 판매 방식
>
> 금융당국 등록 후 가능, 보험사와 전속관계
>
> 최근에는 금융 전반의 컨설팅까지 제공

### GA

> 여러 보험사의 상품을 제공하는 법인보험대리점
>
> **단점**
>
> - 높은 수수료와 불완전 판매 비율
> - 전문성/배당책임 제도 미흡
>
> **자회사형 Ga**
>
> - 경영환경 변화에 대응
>   - 소비자 니즈 충족 가능
>   - 전속설계사의 이탈 방지
>   - 판매 채널 다변
> - 보험회사 비용관리
>   - 판매/수수료/인력 비용 감소
> - 규제환경 변화
